<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>黑白棋大师 - 顶级 AI 版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 棋盘 3D 效果与动画 */
        .perspective-1000 { perspective: 1000px; }
        .transform-style-3d { transform-style: preserve-3d; }
        .backface-hidden { backface-visibility: hidden; }
        .rotate-y-180 { transform: rotateY(180deg); }
        
        /* 棋子阴影 */
        .piece-shadow {
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4), inset 2px 2px 5px rgba(255, 255, 255, 0.2), inset -2px -2px 5px rgba(0, 0, 0, 0.2);
        }

        /* 木纹背景 */
        .board-texture {
            background-color: #2d6b46;
            background-image: linear-gradient(30deg, #265c3c 12%, transparent 12.5%, transparent 87%, #265c3c 87.5%, #265c3c),
            linear-gradient(150deg, #265c3c 12%, transparent 12.5%, transparent 87%, #265c3c 87.5%, #265c3c),
            linear-gradient(30deg, #265c3c 12%, transparent 12.5%, transparent 87%, #265c3c 87.5%, #265c3c),
            linear-gradient(150deg, #265c3c 12%, transparent 12.5%, transparent 87%, #265c3c 87.5%, #265c3c),
            linear-gradient(60deg, #2a6341 25%, transparent 25.5%, transparent 75%, #2a6341 75%, #2a6341),
            linear-gradient(60deg, #2a6341 25%, transparent 25.5%, transparent 75%, #2a6341 75%, #2a6341);
            background-size: 20px 35px;
            background-position: 0 0, 0 0, 10px 18px, 10px 18px, 0 0, 10px 18px;
        }

        /* 标记点 */
        .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        /* 加载动画 */
        .thinking-pulse {
            animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.8; box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { transform: scale(1); opacity: 0; box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { transform: scale(0.8); opacity: 0; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen flex flex-col items-center justify-center p-4">

    <!-- 顶部状态栏 -->
    <div class="w-full max-w-2xl flex justify-between items-center mb-6 bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700">
        <div class="flex items-center gap-4">
            <div class="flex flex-col items-center">
                <span class="text-sm text-gray-400 mb-1">黑棋 (玩家)</span>
                <div class="w-12 h-12 rounded-full bg-black piece-shadow border-2 border-gray-600 flex items-center justify-center text-xl font-bold" id="score-black">2</div>
            </div>
            <div class="text-2xl font-bold text-gray-500">VS</div>
            <div class="flex flex-col items-center">
                <span class="text-sm text-gray-400 mb-1">白棋 (AI)</span>
                <div class="w-12 h-12 rounded-full bg-white piece-shadow text-black flex items-center justify-center text-xl font-bold" id="score-white">2</div>
            </div>
        </div>
        
        <div class="flex flex-col items-end">
            <div id="status-text" class="text-lg font-semibold text-green-400">轮到黑棋</div>
            <div class="text-xs text-gray-500 mt-1 font-mono" id="ai-stats">深度: 0 | 节点: 0 | 耗时: 0ms</div>
            <div class="text-xs text-blue-400 mt-0.5 font-mono hidden" id="ai-eval">评估: 0</div>
        </div>
    </div>

    <!-- 游戏主区域 -->
    <div class="relative">
        <!-- 棋盘背景与边框 -->
        <div class="bg-[#1a1a1a] p-3 rounded-lg shadow-2xl border-4 border-[#3d2b1f]">
            <!-- 8x8 网格 -->
            <div class="grid grid-cols-8 gap-1 bg-[#1a1a1a] border-2 border-black" id="board" style="width: min(90vw, 500px); height: min(90vw, 500px);">
                <!-- 格子由 JS 生成 -->
            </div>
            
            <!-- 棋盘上的标记点 (星位) -->
            <div class="absolute top-[3px] left-[3px] w-full h-full pointer-events-none z-10" id="dots-container" style="width: min(90vw, 500px); height: min(90vw, 500px);"></div>
        </div>

        <!-- AI 思考时的遮罩 -->
        <div id="ai-thinking" class="absolute inset-0 bg-black/20 z-20 hidden flex items-center justify-center rounded-lg">
            <div class="bg-gray-900/90 text-blue-400 px-6 py-3 rounded-full flex items-center gap-3 border border-blue-500/30 shadow-xl backdrop-blur-sm">
                <div class="w-3 h-3 bg-blue-500 rounded-full thinking-pulse"></div>
                <span class="font-bold tracking-wider">AI 思考中...</span>
            </div>
        </div>
    </div>

    <!-- 控制面板 -->
    <div class="w-full max-w-2xl mt-8 grid grid-cols-1 md:grid-cols-2 gap-4">
        <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
            <label class="block text-sm text-gray-400 mb-2">AI 强度 (Level <span id="difficulty-val">8</span>)</label>
            <input type="range" min="1" max="10" value="8" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500" id="difficulty-slider">
            <div class="flex justify-between text-xs text-gray-500 mt-1">
                <span>新手</span>
                <span>普通</span>
                <span>大师</span>
                <span class="text-red-400 font-bold">无敌</span>
            </div>
        </div>

        <div class="grid grid-cols-3 gap-2">
            <button onclick="game.newGame()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition shadow-lg active:transform active:scale-95">
                新局
            </button>
            <button onclick="game.undo()" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition shadow-lg active:transform active:scale-95">
                悔棋
            </button>
            <button onclick="game.switchSide()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition shadow-lg active:transform active:scale-95">
                换边
            </button>
        </div>
    </div>
    
    <div class="mt-4 text-gray-500 text-xs text-center">
        Powered by PVS / Bitboard / Zobrist Hash / Endgame Solver
    </div>

    <!-- AI WORKER SCRIPT (作为 Blob 载入，避免跨域和多文件问题) -->
    <script id="worker-code" type="javascript/worker">
        /* * 高性能黑白棋 AI 核心 (Web Worker)
         * 使用 BigInt 实现 64 位 Bitboard
         */

        // --- 常量定义 ---
        const BLACK = 0;
        const WHITE = 1;
        const EMPTY = 2;
        
        // 位运算辅助常量
        const MASK_CORNER = 0x8100000000000081n;
        const MASK_X_SQUARES = 0x0042000000004200n;
        const MASK_C_SQUARES = 0x4281000000008142n;

        // 边界掩码 (防止左右移动时穿过边界)
        const NOT_A_FILE = 0xfefefefefefefefen; // ~Col A
        const NOT_H_FILE = 0x7f7f7f7f7f7f7f7fn; // ~Col H
        
        // Zobrist Hash 表
        let zobristTable = [];
        let zobristTurn = 0n;

        // 置换表
        const TT_SIZE = 1 << 20; // ~100万个条目
        let tt = new Map(); // 使用 Map 代替固定数组以节省初始内存，JS Map 性能足够好

        // 预计算数据
        let movesArray = new Int8Array(64); // 用于复用

        // 初始化
        function initAI() {
            // 初始化 Zobrist
            for (let i = 0; i < 64; i++) {
                zobristTable[i] = [randomBigInt(), randomBigInt()];
            }
            zobristTurn = randomBigInt();
        }

        function randomBigInt() {
            let n = 0n;
            for (let i = 0; i < 64; i++) {
                if (Math.random() > 0.5) n |= (1n << BigInt(i));
            }
            return n;
        }

        // --- Bitboard 核心逻辑 ---

        // 计算设置的位数 (Population Count)
        function popcnt(b) {
            let c = 0;
            while (b > 0n) {
                b &= (b - 1n);
                c++;
            }
            return c;
        }

        // Kogge-Stone 算法生成合法走法
        function getMoves(own, opp) {
            let empty = ~(own | opp);
            let candidates = 0n;
            
            // 8个方向的位移生成器
            // 修复 BUG: 之前 NE 和 NW 的掩码写反了，导致对角线移动会发生“穿墙” (H列穿到A列)
            const shifts = [
                (b) => (b & NOT_H_FILE) << 1n, // East (+1)
                (b) => (b & NOT_A_FILE) >> 1n, // West (-1)
                (b) => (b << 8n),              // South (+8)
                (b) => (b >> 8n),              // North (-8)
                (b) => (b & NOT_H_FILE) << 9n, // SouthEast (+9)
                (b) => (b & NOT_H_FILE) >> 7n, // NorthEast (-7) (注意: H列向右上会越界到下一行A列，必须 mask H)
                (b) => (b & NOT_A_FILE) << 7n, // SouthWest (+7)
                (b) => (b & NOT_A_FILE) >> 9n  // NorthWest (-9) (注意: A列向左上会越界到上一行H列，必须 mask A)
            ];

            for (let shift of shifts) {
                let x = shift(own) & opp;
                x |= shift(x) & opp;
                x |= shift(x) & opp;
                x |= shift(x) & opp;
                x |= shift(x) & opp;
                x |= shift(x) & opp;
                candidates |= shift(x) & empty;
            }

            return candidates;
        }

        // 计算翻转的棋子 (不改变状态，只返回翻转位的掩码)
        // 修正版：移除了导致死循环的错误代码块
        function getFlips(move, own, opp) {
            let flips = 0n;
            // 逐格扫描，确保准确性
            for (let dir of [-1, 1, -8, 8, -9, -7, 7, 9]) {
                let r = Math.floor(move / 8);
                let c = move % 8;
                let dr = 0, dc = 0;
                
                if (dir === -1) dc = -1;
                else if (dir === 1) dc = 1;
                else if (dir === -8) dr = -1;
                else if (dir === 8) dr = 1;
                else if (dir === -9) { dr = -1; dc = -1; }
                else if (dir === -7) { dr = -1; dc = 1; }
                else if (dir === 7) { dr = 1; dc = -1; }
                else if (dir === 9) { dr = 1; dc = 1; }

                let r1 = r + dr, c1 = c + dc;
                let currentMask = 0n;
                let valid = false;

                while (r1 >= 0 && r1 < 8 && c1 >= 0 && c1 < 8) {
                    let idx = r1 * 8 + c1;
                    let bit = 1n << BigInt(idx);
                    
                    if ((opp & bit) !== 0n) {
                        currentMask |= bit;
                    } else if ((own & bit) !== 0n) {
                        valid = true;
                        break;
                    } else {
                        break;
                    }
                    r1 += dr; c1 += dc;
                }
                if (valid) flips |= currentMask;
            }
            return flips;
        }

        // --- 评估函数 ---

        // 位置权重图 (8x8)
        // 100, -20, 10,  5,  5, 10, -20, 100
        // -20, -50, -2, -2, -2, -2, -50, -20
        //  10,  -2, -1, -1, -1, -1,  -2,  10
        //   5,  -2, -1, -1, -1, -1,  -2,   5
        // ... 对称
        const WEIGHTS = [
             100, -20, 10,  5,  5, 10, -20, 100,
             -20, -50, -2, -2, -2, -2, -50, -20,
              10,  -2, -1, -1, -1, -1,  -2,  10,
               5,  -2, -1, -1, -1, -1,  -2,   5,
               5,  -2, -1, -1, -1, -1,  -2,   5,
              10,  -2, -1, -1, -1, -1,  -2,  10,
             -20, -50, -2, -2, -2, -2, -50, -20,
             100, -20, 10,  5,  5, 10, -20, 100
        ];

        function evaluate(own, opp, ownMoves, oppMoves, emptyCount) {
            let score = 0;

            // 1. 位置权重
            // 这部分可以用位操作优化，但循环 64 次在 JS 中依然很快
            let myPos = own;
            let opPos = opp;
            for(let i=0; i<64; i++) {
                if ((myPos & 1n)) score += WEIGHTS[i];
                else if ((opPos & 1n)) score -= WEIGHTS[i];
                myPos >>= 1n;
                opPos >>= 1n;
            }

            // 2. 行动力 (Mobility)
            // 能够走的步数越多越好，限制对手越好
            let myMob = popcnt(ownMoves);
            let opMob = popcnt(oppMoves);
            // 动态权重：前期行动力重要，后期棋子数重要
            let mobWeight = (emptyCount > 20) ? 15 : 5;
            score += (myMob - opMob) * mobWeight;

            // 3. 潜在行动力 (Frontier Disks) - 简化的
            // 靠近空位的棋子通常不好
            // 此处省略复杂位运算，用Mobility大致覆盖

            // 4. 奇偶性 (Parity)
            // 如果空位是偶数，最后一步是后手下（通常有利）
            // 简单处理：如果是最后几步，给予最后下子的一方加分

            // 5. 棋子差 (Disc Difference) - 仅在终局前非常接近时或终局计算
            if (emptyCount < 10) {
                score += (popcnt(own) - popcnt(opp)) * 10;
            }

            return score;
        }

        // --- 搜索算法 (PVS) ---

        let nodes = 0;
        let stopSearch = false;
        let startTime = 0;
        let timeLimit = 1000;

        function search(own, opp, turn, depth, alpha, beta, passed) {
            nodes++;
            
            // 定期检查时间 (每 2048 个节点)
            if ((nodes & 2047) === 0) {
                if (Date.now() - startTime > timeLimit) {
                    stopSearch = true;
                }
            }
            if (stopSearch) return 0;

            // 哈希检查 (置换表)
            // 简化：这里不做完整 Zobrist，因为 JS Map 对于大数据量存取有开销
            // 若要极致性能，需实现基于 ArrayBuffer 的 TT
            
            let legalMoves = getMoves(own, opp);

            // 游戏结束判定
            if (legalMoves === 0n) {
                if (passed) {
                    // 双方都 pass，游戏结束
                    let diff = popcnt(own) - popcnt(opp);
                    if (diff > 0) return 10000 + diff;
                    if (diff < 0) return -10000 + diff;
                    return 0;
                }
                // 我方无棋可走，让给对方
                return -search(opp, own, 1-turn, depth, -beta, -alpha, true);
            }

            // 叶子节点
            if (depth === 0) {
                let oppMoves = getMoves(opp, own);
                let empty = 64 - popcnt(own | opp);
                return evaluate(own, opp, legalMoves, oppMoves, empty);
            }

            // 走法生成与排序
            let moves = [];
            let temp = legalMoves;
            while (temp > 0n) {
                // 提取最低位的 1 (LSB)
                let lsb = temp & -temp; // BigInt 负数是补码
                // 找出位置索引
                // BigInt 没有 Math.log2，需要快速转换
                let idx = -1;
                // 简单查找（或者使用去重表）
                // 这里的位操作转索引在 JS BigInt 中稍慢，但可接受
                let str = lsb.toString(2);
                idx = str.length - 1; 

                // 启发式排序分数
                let sortScore = 0;
                // 角点优先
                if (lsb & MASK_CORNER) sortScore = 1000;
                // 避免 C/X 位 (简单判断)
                else if (lsb & MASK_X_SQUARES) sortScore = -100;
                else if (lsb & MASK_C_SQUARES) sortScore = -50;
                
                moves.push({ bits: lsb, idx: idx, score: sortScore });
                temp ^= lsb; // 清除最低位
            }

            // 排序：分数高的在前
            moves.sort((a, b) => b.score - a.score);

            // PVS 核心循环
            let bestScore = -Infinity;
            let b = beta;
            
            for (let i = 0; i < moves.length; i++) {
                let m = moves[i];
                let flips = getFlips(m.idx, own, opp);
                
                // 执行走法
                let newOwn = own | m.bits | flips;
                let newOpp = opp & ~flips;

                let score;
                if (i === 0) {
                    score = -search(newOpp, newOwn, 1-turn, depth - 1, -b, -alpha, false);
                } else {
                    // Null window search
                    score = -search(newOpp, newOwn, 1-turn, depth - 1, -alpha - 1, -alpha, false);
                    if (score > alpha && score < beta) {
                        // Re-search
                        score = -search(newOpp, newOwn, 1-turn, depth - 1, -beta, -alpha, false);
                    }
                }
                
                if (stopSearch) return 0;

                if (score > bestScore) {
                    bestScore = score;
                }
                if (score > alpha) {
                    alpha = score;
                    if (alpha >= beta) break; // Beta 剪枝
                }
            }

            return bestScore;
        }

        // 终局完美解 (Endgame Solver)
        function solveEndgame(own, opp, alpha, beta, passed) {
            nodes++;
            // 终局不限时，或者给一个很大的限制
            // 这里为了防止浏览器卡死，还是保留 stopSearch 检查，但由主线程控制

            let legalMoves = getMoves(own, opp);

            if (legalMoves === 0n) {
                if (passed) {
                    let diff = popcnt(own) - popcnt(opp);
                    if (diff > 0) return 10000 + diff; // 赢
                    if (diff < 0) return -10000 + diff; // 输
                    return 0; // 平
                }
                return -solveEndgame(opp, own, -beta, -alpha, true);
            }

            let temp = legalMoves;
            let bestScore = -Infinity;

            // Move Ordering is less critical in pure endgame solver but still helps
            // 直接遍历
            while (temp > 0n) {
                let lsb = temp & -temp;
                // 获取索引
                let s = lsb.toString(2);
                let idx = s.length - 1; 
                
                let flips = getFlips(idx, own, opp);
                let newOwn = own | lsb | flips;
                let newOpp = opp & ~flips;

                let val = -solveEndgame(newOpp, newOwn, -beta, -alpha, false);
                
                if (val > bestScore) bestScore = val;
                if (val > alpha) {
                    alpha = val;
                    if (alpha >= beta) break;
                }
                temp ^= lsb;
            }
            return bestScore;
        }


        // --- 主接口 ---
        
        // 迭代加深搜索
        function getBestMove(boardBlackStr, boardWhiteStr, color, level) {
            // 解析 BigInt
            let own = (color === BLACK) ? BigInt(boardBlackStr) : BigInt(boardWhiteStr);
            let opp = (color === BLACK) ? BigInt(boardWhiteStr) : BigInt(boardBlackStr);
            
            nodes = 0;
            stopSearch = false;
            startTime = Date.now();

            let emptyCount = 64 - popcnt(own | opp);
            
            // 难度配置
            let maxDepth;
            if (level <= 2) maxDepth = 1;
            else if (level <= 4) maxDepth = 4;
            else if (level <= 6) maxDepth = 6;
            else if (level <= 8) maxDepth = 10;
            else maxDepth = 20; // 几乎无限制

            // 时间限制 (毫秒)
            if (level >= 10) timeLimit = 5000; // 最强模式给5秒
            else timeLimit = 1500; // 普通模式快一点

            // 终局模式触发
            // 如果剩余步数很少，且等级高，直接全算
            if (emptyCount <= 16 && level >= 9) {
                // 切换到 SolveEndgame 逻辑，不限制深度
                // 这里简单复用 search 结构但深度设为 64
                // 为了 UX，这里如果步数非常少(<=14)可以全搜，稍微多一点用深层搜索
                maxDepth = 64;
                timeLimit = 10000;
            }

            let legalMoves = getMoves(own, opp);
            if (legalMoves === 0n) return -1; // Pass

            // 生成候选走法列表
            let moves = [];
            let temp = legalMoves;
            while (temp > 0n) {
                let lsb = temp & -temp;
                let s = lsb.toString(2);
                let idx = s.length - 1;
                moves.push({ bits: lsb, idx: idx });
                temp ^= lsb;
            }

            // 单一步骤直接返回
            if (moves.length === 1) return moves[0].idx;

            let bestMove = moves[0].idx;
            let currentBestScore = -Infinity;

            // 迭代加深循环
            for (let d = 1; d <= maxDepth; d++) {
                let alpha = -Infinity;
                let beta = Infinity;
                
                // 当前深度的最佳候选
                let iterBestMove = -1;
                let iterBestScore = -Infinity;

                // 根节点搜索
                // 对第一层进行排序优化？(利用上一层的结果)
                // 简单起见，按顺序搜

                for (let i = 0; i < moves.length; i++) {
                    let m = moves[i];
                    let flips = getFlips(m.idx, own, opp);
                    let newOwn = own | m.bits | flips;
                    let newOpp = opp & ~flips;

                    let score;
                    // 若是终局模式，直接递归到底
                    if (emptyCount <= 14 && level >= 9) {
                         score = -solveEndgame(newOpp, newOwn, -beta, -alpha, false);
                    } else {
                         score = -search(newOpp, newOwn, 1-color, d - 1, -beta, -alpha, false);
                    }

                    // 检查超时
                    if (stopSearch) break;

                    m.lastScore = score; // 记录分数用于下一轮排序（简单实现）

                    if (score > iterBestScore) {
                        iterBestScore = score;
                        iterBestMove = m.idx;
                    }
                    if (score > alpha) alpha = score;
                }

                if (stopSearch) break;

                // 完成了一整层的搜索
                bestMove = iterBestMove;
                currentBestScore = iterBestScore;
                
                // 将上一层最好的步法排到最前 (简单 Move Ordering)
                moves.sort((a, b) => b.lastScore - a.lastScore);

                // 发送进度
                postMessage({ type: 'progress', depth: d, nodes: nodes, time: Date.now() - startTime, score: currentBestScore });
                
                // 如果找到必胜路径 (分数极大)
                if (currentBestScore > 9000) break;
                // 如果终局全搜完成
                if (d >= emptyCount) break;
            }

            return bestMove;
        }

        initAI();

        self.onmessage = function(e) {
            const data = e.data;
            if (data.type === 'think') {
                const move = getBestMove(data.black, data.white, data.color, data.level);
                postMessage({ type: 'done', move: move, nodes: nodes, time: Date.now() - startTime });
            }
        };
    </script>

    <!-- 主逻辑 JS -->
    <script>
        const BLACK = 0;
        const WHITE = 1;
        const EMPTY = 2;

        class OthelloGame {
            constructor() {
                this.board = new Array(64).fill(EMPTY);
                this.turn = BLACK; // 黑先
                this.history = [];
                this.aiWorker = null;
                this.aiLevel = 8;
                this.isThinking = false;
                this.userColor = BLACK; 
                this.gameOver = false;
                
                this.initWorker();
                this.initBoardUI();
                this.newGame();

                // UI 绑定
                document.getElementById('difficulty-slider').addEventListener('input', (e) => {
                    this.aiLevel = parseInt(e.target.value);
                    document.getElementById('difficulty-val').innerText = this.aiLevel;
                });
            }

            initWorker() {
                const blob = new Blob([document.getElementById('worker-code').textContent], { type: "text/javascript" });
                this.aiWorker = new Worker(URL.createObjectURL(blob));
                
                this.aiWorker.onmessage = (e) => {
                    const data = e.data;
                    if (data.type === 'progress') {
                        document.getElementById('ai-stats').innerText = `深度: ${data.depth} | 节点: ${(data.nodes/1000).toFixed(1)}k | 耗时: ${data.time}ms`;
                        document.getElementById('ai-eval').innerText = `评估: ${data.score}`;
                        document.getElementById('ai-eval').classList.remove('hidden');
                    } else if (data.type === 'done') {
                        this.isThinking = false;
                        document.getElementById('ai-thinking').classList.add('hidden');
                        document.getElementById('status-text').innerText = (this.turn === BLACK ? "轮到黑棋" : "轮到白棋");
                        
                        if (data.move !== -1) {
                            this.makeMove(data.move);
                        } else {
                            // AI Pass
                            this.passTurn();
                        }
                    }
                };
            }

            initBoardUI() {
                const boardEl = document.getElementById('board');
                const dotsEl = document.getElementById('dots-container');
                boardEl.innerHTML = '';
                dotsEl.innerHTML = '';

                // 生成格子
                for (let i = 0; i < 64; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-full h-full bg-green-700 relative cursor-pointer hover:bg-green-600 transition-colors duration-200 flex items-center justify-center';
                    cell.dataset.idx = i;
                    cell.onclick = () => this.handleUserClick(i);
                    
                    // 棋子元素
                    const disc = document.createElement('div');
                    disc.className = 'w-[80%] h-[80%] rounded-full transition-all duration-500 transform-style-3d';
                    disc.id = `disc-${i}`;
                    
                    // 棋子正面 (黑)
                    const blackFace = document.createElement('div');
                    blackFace.className = 'absolute inset-0 bg-black rounded-full backface-hidden piece-shadow border-2 border-gray-700';
                    // 棋子反面 (白)
                    const whiteFace = document.createElement('div');
                    whiteFace.className = 'absolute inset-0 bg-white rounded-full backface-hidden rotate-y-180 piece-shadow border-2 border-gray-200';

                    disc.appendChild(blackFace);
                    disc.appendChild(whiteFace);
                    cell.appendChild(disc);
                    boardEl.appendChild(cell);
                    
                    // 默认隐藏
                    this.updateDiscUI(i, EMPTY);
                }

                // 添加星位 (Dots)
                const stars = [18, 21, 42, 45];
                stars.forEach(idx => {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    // 计算位置
                    const row = Math.floor(idx / 8);
                    const col = idx % 8;
                    // 使用百分比定位
                    dot.style.top = `calc(${row * 12.5}% - 4px + 6.25%)`; 
                    dot.style.left = `calc(${col * 12.5}% - 4px + 6.25%)`;
                    dotsEl.appendChild(dot);
                });
            }

            updateDiscUI(idx, type) {
                const disc = document.getElementById(`disc-${idx}`);
                if (type === EMPTY) {
                    disc.style.opacity = '0';
                    disc.style.transform = 'scale(0)';
                } else if (type === BLACK) {
                    disc.style.opacity = '1';
                    disc.style.transform = 'scale(1) rotateY(0deg)';
                } else if (type === WHITE) {
                    disc.style.opacity = '1';
                    disc.style.transform = 'scale(1) rotateY(180deg)';
                }
            }

            newGame() {
                this.board.fill(EMPTY);
                this.board[27] = WHITE;
                this.board[28] = BLACK;
                this.board[35] = BLACK;
                this.board[36] = WHITE;
                
                this.turn = BLACK;
                this.history = [];
                this.gameOver = false;
                this.isThinking = false;
                
                this.renderBoard();
                this.updateStatus();
                this.checkTurn();
            }

            renderBoard() {
                for(let i=0; i<64; i++) {
                    this.updateDiscUI(i, this.board[i]);
                }
                
                // 辅助：高亮最后一步
                document.querySelectorAll('#board > div').forEach(d => d.classList.remove('ring', 'ring-yellow-400', 'ring-opacity-50'));
                if (this.history.length > 0) {
                    const lastMove = this.history[this.history.length-1].move;
                    if (lastMove >= 0) {
                        const cell = document.querySelector(`div[data-idx="${lastMove}"]`);
                        if(cell) cell.classList.add('ring', 'ring-4', 'ring-yellow-400', 'ring-opacity-50', 'z-10');
                    }
                }

                // 高亮可行步 (仅当玩家回合)
                document.querySelectorAll('.hint-dot').forEach(el => el.remove());
                if (this.turn === this.userColor && !this.gameOver) {
                    const moves = this.getValidMoves(this.turn);
                    moves.forEach(m => {
                        const cell = document.querySelector(`div[data-idx="${m}"]`);
                        const hint = document.createElement('div');
                        hint.className = 'hint-dot w-3 h-3 bg-green-400/50 rounded-full absolute pointer-events-none';
                        cell.appendChild(hint);
                    });
                }
            }

            updateStatus() {
                const blackCount = this.board.filter(c => c === BLACK).length;
                const whiteCount = this.board.filter(c => c === WHITE).length;
                document.getElementById('score-black').innerText = blackCount;
                document.getElementById('score-white').innerText = whiteCount;
                
                if (this.gameOver) {
                    let msg = "";
                    if (blackCount > whiteCount) msg = "黑棋获胜！";
                    else if (whiteCount > blackCount) msg = "白棋获胜！";
                    else msg = "平局！";
                    document.getElementById('status-text').innerText = msg;
                    document.getElementById('status-text').className = "text-lg font-bold text-yellow-400 animate-bounce";
                } else {
                    const colorName = this.turn === BLACK ? "黑棋" : "白棋";
                    const isUser = this.turn === this.userColor;
                    document.getElementById('status-text').innerText = `轮到${colorName} ${isUser ? '(你)' : '(AI)'}`;
                    document.getElementById('status-text').className = `text-lg font-semibold ${this.turn === BLACK ? 'text-gray-300' : 'text-white'}`;
                }
            }

            // --- 游戏逻辑 ---

            isValidMove(move, color) {
                if (this.board[move] !== EMPTY) return false;
                const opp = 1 - color;
                const dirs = [-9, -8, -7, -1, 1, 7, 8, 9];
                
                for (let dir of dirs) {
                    let r = Math.floor(move / 8);
                    let c = move % 8;
                    let r1 = r + Math.floor(dir/8) + (Math.abs(dir)<2 ? 0 : (dir>0?1:-1)*(Math.abs(dir)%8===0?1:0)); 
                    // 这种计算 dir 太麻烦，直接硬编码 offset 对应的 dr/dc
                    let dr=0, dc=0;
                    if(dir===-9){dr=-1;dc=-1;} else if(dir===-8){dr=-1;dc=0;} else if(dir===-7){dr=-1;dc=1;}
                    else if(dir===-1){dr=0;dc=-1;} else if(dir===1){dr=0;dc=1;}
                    else if(dir===7){dr=1;dc=-1;} else if(dir===8){dr=1;dc=0;} else if(dir===9){dr=1;dc=1;}

                    let nr = r + dr, nc = c + dc;
                    let hasOpp = false;
                    
                    while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        const idx = nr * 8 + nc;
                        if (this.board[idx] === opp) {
                            hasOpp = true;
                        } else if (this.board[idx] === color) {
                            if (hasOpp) return true;
                            break;
                        } else {
                            break;
                        }
                        nr += dr; nc += dc;
                    }
                }
                return false;
            }

            getValidMoves(color) {
                let moves = [];
                for (let i = 0; i < 64; i++) {
                    if (this.isValidMove(i, color)) moves.push(i);
                }
                return moves;
            }

            flip(move, color) {
                const opp = 1 - color;
                let flipped = [];
                const dirs = [-9, -8, -7, -1, 1, 7, 8, 9];
                
                // 简单的 flip 逻辑，不需要位运算那么快，因为只执行一次
                for (let dir of dirs) {
                    let dr=0, dc=0;
                    if(dir===-9){dr=-1;dc=-1;} else if(dir===-8){dr=-1;dc=0;} else if(dir===-7){dr=-1;dc=1;}
                    else if(dir===-1){dr=0;dc=-1;} else if(dir===1){dr=0;dc=1;}
                    else if(dir===7){dr=1;dc=-1;} else if(dir===8){dr=1;dc=0;} else if(dir===9){dr=1;dc=1;}

                    let r = Math.floor(move / 8);
                    let c = move % 8;
                    let nr = r + dr, nc = c + dc;
                    let potential = [];
                    
                    while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        const idx = nr * 8 + nc;
                        if (this.board[idx] === opp) {
                            potential.push(idx);
                        } else if (this.board[idx] === color) {
                            if (potential.length > 0) flipped.push(...potential);
                            break;
                        } else {
                            break;
                        }
                        nr += dr; nc += dc;
                    }
                }
                return flipped;
            }

            makeMove(move) {
                // 保存历史
                this.history.push({
                    board: [...this.board],
                    turn: this.turn,
                    move: move
                });

                this.board[move] = this.turn;
                const flipped = this.flip(move, this.turn);
                flipped.forEach(idx => this.board[idx] = this.turn);
                
                this.turn = 1 - this.turn;
                this.renderBoard();
                this.updateStatus();
                
                // 延时一点检查，让动画播放
                setTimeout(() => this.checkTurn(), 300);
            }

            passTurn() {
                console.log("Pass");
                // 双方都无棋可走？
                if (this.getValidMoves(1-this.turn).length === 0) {
                    this.gameOver = true;
                    this.updateStatus();
                    return;
                }

                this.history.push({
                    board: [...this.board],
                    turn: this.turn,
                    move: -1 // pass
                });
                
                this.turn = 1 - this.turn;
                this.updateStatus();
                setTimeout(() => this.checkTurn(), 500);
            }

            checkTurn() {
                if (this.gameOver) return;
                
                const validMoves = this.getValidMoves(this.turn);
                if (validMoves.length === 0) {
                    // 连 Pass 检查
                    const oppMoves = this.getValidMoves(1 - this.turn);
                    if (oppMoves.length === 0) {
                        this.gameOver = true;
                        this.updateStatus();
                        return;
                    }
                    alert((this.turn === BLACK ? "黑方" : "白方") + "无子可下，跳过回合");
                    this.passTurn();
                    return;
                }

                if (this.turn !== this.userColor) {
                    // AI 回合
                    this.runAI();
                } else {
                    this.renderBoard(); // 显示提示点
                }
            }

            handleUserClick(idx) {
                if (this.gameOver || this.turn !== this.userColor || this.isThinking) return;
                if (!this.isValidMove(idx, this.turn)) return;
                
                this.makeMove(idx);
            }

            runAI() {
                this.isThinking = true;
                document.getElementById('ai-thinking').classList.remove('hidden');
                document.getElementById('status-text').innerText = "AI 正在思考...";
                
                // 转换棋盘为 BigInt
                let b = 0n, w = 0n;
                for(let i=0; i<64; i++) {
                    if (this.board[i] === BLACK) b |= (1n << BigInt(i));
                    else if (this.board[i] === WHITE) w |= (1n << BigInt(i));
                }

                this.aiWorker.postMessage({
                    type: 'think',
                    black: b.toString(), // BigInt 传给 Worker 最好转字符串
                    white: w.toString(),
                    color: this.turn,
                    level: this.aiLevel
                });
            }

            undo() {
                if (this.history.length === 0 || this.isThinking) return;
                // 悔棋通常悔两步（回到自己回合）
                let target = this.history.length - 1;
                // 如果当前是 AI 回合，回退一步；如果是玩家回合，回退两步
                if (this.turn !== this.userColor) {
                    target = this.history.length - 1;
                } else {
                    target = this.history.length - 2;
                }
                
                if (target < 0) {
                    // 回到初始
                    this.newGame();
                    return;
                }

                const state = this.history[target];
                this.board = [...state.board];
                this.turn = state.turn;
                this.history = this.history.slice(0, target);
                this.gameOver = false;
                this.renderBoard();
                this.updateStatus();
            }

            switchSide() {
                if (this.history.length > 0) {
                    if(!confirm("换边将重新开始游戏，确定吗？")) return;
                }
                this.userColor = 1 - this.userColor;
                this.newGame();
                // 如果换边后玩家是白棋，AI (黑) 先走
                if (this.userColor === WHITE) {
                    setTimeout(() => this.runAI(), 500);
                }
            }
        }

        // 启动游戏
        const game = new OthelloGame();
    </script>
</body>
</html>
