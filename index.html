<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»‘ç™½æ£‹ (Othello) - äººæœºå¯¹æˆ˜</title>
    <style>
        :root {
            --board-bg: #2e7d32; /* ç»å…¸çš„æ£‹ç›˜ç»¿ */
            --board-border: #1b5e20;
            --cell-border: rgba(0, 0, 0, 0.2);
            --black-piece: #1a1a1a;
            --white-piece: #f0f0f0;
            --hint-color: rgba(0, 0, 0, 0.2);
            --hint-hover: rgba(0, 0, 0, 0.4);
            --primary-btn: #1976d2;
            --primary-btn-hover: #1565c0;
            --text-color: #333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #eef2f3;
            color: var(--text-color);
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        /* --- ä¿¡æ¯é¢æ¿ --- */
        .info-panel {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: white;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 500px;
            justify-content: space-around;
            align-items: center;
        }

        .score-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .score-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-indicator.black { background-color: var(--black-piece); }
        .score-indicator.white { background-color: var(--white-piece); border: 1px solid #ccc; }

        .turn-display {
            font-weight: bold;
            color: #d32f2f; /* é†’ç›®çš„é¢œè‰²æ˜¾ç¤ºå½“å‰å›åˆ */
            padding: 5px 15px;
            background: #ffebee;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        /* --- æ£‹ç›˜ --- */
        .board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            background-color: var(--board-border);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            background-color: var(--board-border); /* ä½¿ç”¨æ·±è‰²èƒŒæ™¯ï¼Œè®© gap æ˜¾ç¤ºä¸ºçº¿æ¡ */
            gap: 2px; /* ç½‘æ ¼çº¿å®½åº¦ */
            border: 4px solid var(--board-border); /* åŠ ç²—å¤–è¾¹æ¡† */
        }

        .cell {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: var(--board-bg);
            cursor: default;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* åªæœ‰åˆæ³•çš„æ ¼å­æ‰æœ‰é¼ æ ‡æ‰‹åŠ¿ */
        .cell.valid {
            cursor: pointer;
        }

        /* æç¤ºç‚¹ (Legal Move Hint) */
        .cell.valid::after {
            content: '';
            width: 30%;
            height: 30%;
            background-color: var(--hint-color);
            border-radius: 50%;
            transition: transform 0.2s, background-color 0.2s;
        }

        .cell.valid:hover::after {
            background-color: var(--hint-hover);
            transform: scale(1.2);
        }

        /* --- æ£‹å­ --- */
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5), inset -2px -2px 5px rgba(0,0,0,0.2);
            position: absolute;
            transition: transform 0.4s ease-in-out, background-color 0.4s;
            backface-visibility: hidden;
        }

        .piece.black {
            background-color: var(--black-piece);
            background: radial-gradient(circle at 30% 30%, #444, var(--black-piece));
        }

        .piece.white {
            background-color: var(--white-piece);
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
        }

        /* ç¿»è½¬åŠ¨ç”»çš„è¾…åŠ©ç±» */
        .piece.flipping {
            transform: scale(0);
        }

        /* --- æ§åˆ¶åŒº --- */
        .controls {
            margin-top: 25px;
        }

        .btn {
            background-color: var(--primary-btn);
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background-color: var(--primary-btn-hover);
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* --- é€šç”¨å¼¹çª— (æ¸¸æˆç»“æŸ / åˆå§‹è®¾ç½®) --- */
        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-box {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            max-width: 90%;
            min-width: 300px;
        }

        .modal-box h2 {
            margin-bottom: 15px;
            color: #333;
        }

        .modal-box p {
            margin-bottom: 25px;
            font-size: 1.1rem;
            color: #555;
        }

        .setup-btns {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn-secondary {
            background-color: #757575;
        }
        .btn-secondary:hover {
            background-color: #616161;
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 600px) {
            .board-container {
                max-width: 90vw;
            }
            .info-panel {
                flex-direction: column;
                gap: 10px;
            }
            .setup-btns {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

    <h1>é»‘ç™½æ£‹ (Reversi)</h1>

    <div class="info-panel">
        <div class="score-box">
            <span class="score-label">é»‘æ£‹</span>
            <span class="score-value">
                <span class="score-indicator black"></span>
                <span id="score-black">2</span>
            </span>
        </div>
        
        <div class="turn-display" id="turn-display">ç­‰å¾…å¼€å§‹...</div>

        <div class="score-box">
            <span class="score-label">ç™½æ£‹</span>
            <span class="score-value">
                <span class="score-indicator white"></span>
                <span id="score-white">2</span>
            </span>
        </div>
    </div>

    <div class="board-container">
        <div class="board" id="board">
            <!-- ç½‘æ ¼ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="game.showSetup()">é‡æ–°å¼€å§‹ (New Game)</button>
    </div>

    <!-- åˆå§‹è®¾ç½®å¼¹çª— -->
    <div class="overlay show" id="setup-overlay">
        <div class="modal-box">
            <h2>å¼€å§‹æ–°æ¸¸æˆ</h2>
            <p>è¯·é€‰æ‹©ä½ çš„é˜µè¥</p>
            <div class="setup-btns">
                <button class="btn" onclick="game.startGame(1)" style="background-color: #212121;">æ‰§é»‘ (å…ˆæ‰‹)</button>
                <button class="btn btn-secondary" onclick="game.startGame(-1)" style="background-color: #9e9e9e; color: black;">æ‰§ç™½ (åæ‰‹)</button>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div class="overlay" id="end-overlay">
        <div class="modal-box">
            <h2 id="msg-title">æ¸¸æˆç»“æŸ</h2>
            <p id="msg-content">é»‘æ£‹èƒœï¼</p>
            <div class="setup-btns">
                <button class="btn" onclick="game.showSetup()">å†æ¥ä¸€å±€</button>
                <button class="btn btn-secondary" onclick="game.closeEndOverlay()">å…³é—­</button>
            </div>
        </div>
    </div>

<script>
/**
 * é»‘ç™½æ£‹ (Othello) é¡¶çº§ AI å¼•æ“
 * å®ç°ç‰¹æ€§ï¼š
 * 1. PVS (Principal Variation Search) + Iterative Deepening
 * 2. Zobrist Hashing + Transposition Table (Map)
 * 3. 2500ms ä¸¥æ ¼æ—¶é—´æ§åˆ¶
 * 4. Move Ordering (Hash > MVV/LVA > Killer > History)
 * 5. èŒä¸šçº§è¯„ä¼°å‡½æ•° (Mobility, Potential Mobility, Stable Discs, Corner/Edge)
 * 6. 18æ­¥å¼€å±€åº“
 */

// --- å…¨å±€å¸¸é‡ & å·¥å…· ---
const ROWS = 8;
const COLS = 8;
const BLACK = 1;
const WHITE = -1;
const EMPTY = 0;

// Zobrist éšæœºæ•°è¡¨
let ZobristTable = [];
let ZobristBlackTurn = 0n;

function initZobrist() {
    // ä½¿ç”¨ BigInt é¿å… JS Number ç²¾åº¦é—®é¢˜
    for (let i = 0; i < 64; i++) {
        ZobristTable[i] = {
            [BLACK]: BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)),
            [WHITE]: BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER))
        };
    }
    ZobristBlackTurn = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
}

// ç®€å•çš„å¼€å±€åº“ (Key: ZobristHash, Value: {r, c}) 
// å®é™…ç”±äº Zobrist æ˜¯éšæœºç”Ÿæˆçš„ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ç®€åŒ–çš„ "Move Sequence String" æ¥åŒ¹é…å¼€å±€
// æ ¼å¼: "f5d6..."
const OPENING_BOOK_SEQUENCES = {
    // å¸¸è§å¼€å±€ï¼šè™å®šå¼ï¼Œç‰›å®šå¼ç­‰ (ç®€åŒ–ç‰ˆ)
    // æ£‹è°±é€šå¸¸ä»¥ "f5" (row 5, col 6) æ ¼å¼ï¼Œè¿™é‡Œè½¬æ¢åæ ‡
    // çº¦å®š: f5=37, d6=43, c3=18, d3=19, c4=26, f4=29, e3=20, etc.
    // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ç¡¬ç¼–ç å‰å‡ æ­¥çš„åº”å¯¹ã€‚
    // é»‘æ£‹å…ˆæ‰‹ f5 (row 2, col 5? No, Othello standard: f5 is (4,5) in 0-indexed? 
    // Standard: a1=0,0. f5 => col 5, row 4.
    // æˆ‘ä»¬ä½¿ç”¨å†…éƒ¨åæ ‡ (r, c)
};

// é¢„å®šä¹‰å¥½çš„å¼€å±€æ ‘ (ç®€åŒ–ç‰ˆï¼Œä»…åº”å¯¹å‰4-6æ‰‹ä¿è¯ä¸äº)
// ç»“æ„: patternString -> [r, c]
const OPENING_RESPONSES = {
    // è¿™æ˜¯ä¸€ä¸ªéå¸¸ç®€åŒ–çš„åº“ï¼Œä¸»è¦ç”¨äºå±•ç¤ºé€»è¾‘
    "": [2, 3], // é»‘æ£‹ç¬¬ä¸€æ‰‹é€šå¸¸ä¸‹ f5 (3,4) æˆ– c4 (2,3)ã€‚è¿™é‡Œé€‰ (2,3)
    "23": [2, 4], 
    "2324": [2, 5],
    "32": [2, 2],
    // æ›´å¤šè°±å¯ä»¥ç»§ç»­è¿½åŠ ...
};

// é™æ€æƒé‡è¡¨ (ä½ç½®åˆ†)
const STATIC_WEIGHTS = [
    [800, -200, 20, 10, 10, 20, -200, 800],
    [-200, -400, -10, -10, -10, -10, -400, -200],
    [ 20,  -10,  5,  2,  2,  5,  -10,  20],
    [ 10,  -10,  2,  1,  1,  2,  -10,  10],
    [ 10,  -10,  2,  1,  1,  2,  -10,  10],
    [ 20,  -10,  5,  2,  2,  5,  -10,  20],
    [-200, -400, -10, -10, -10, -10, -400, -200],
    [800, -200, 20, 10, 10, 20, -200, 800]
];

// æ–¹å‘å‘é‡
const DIRECTIONS = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
];

class OthelloGame {
    constructor() {
        this.board = [];
        this.currentPlayer = BLACK;
        this.gameActive = false;
        
        // AI ç›¸å…³çŠ¶æ€
        this.AI_PLAYER = WHITE;
        this.HUMAN_PLAYER = BLACK;
        this.aiThinking = false;
        
        // æœç´¢å¼•æ“çŠ¶æ€
        this.tt = new Map(); // Transposition Table
        this.historyTable = []; // History Heuristic
        this.killerMoves = []; // Killer Heuristic [depth][0/1]
        this.searchStartTime = 0;
        this.timeLimit = 2500; // ms
        this.nodesSearched = 0;
        this.stopSearch = false;

        // UI ç»‘å®š
        this.boardEl = document.getElementById('board');
        this.scoreBlackEl = document.getElementById('score-black');
        this.scoreWhiteEl = document.getElementById('score-white');
        this.turnDisplayEl = document.getElementById('turn-display');
        this.setupOverlayEl = document.getElementById('setup-overlay');
        this.endOverlayEl = document.getElementById('end-overlay');
        this.msgTitleEl = document.getElementById('msg-title');
        this.msgContentEl = document.getElementById('msg-content');

        initZobrist();
        this.renderEmptyBoard();
    }

    renderEmptyBoard() {
        this.boardEl.innerHTML = '';
        for (let i = 0; i < 64; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            this.boardEl.appendChild(cell);
        }
    }

    showSetup() {
        this.closeEndOverlay();
        this.setupOverlayEl.classList.add('show');
    }

    closeEndOverlay() {
        this.endOverlayEl.classList.remove('show');
    }

    startGame(humanColor) {
        this.HUMAN_PLAYER = humanColor;
        this.AI_PLAYER = -humanColor;
        
        // åˆå§‹åŒ–æ£‹ç›˜
        this.board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
        
        // åˆå§‹å­
        this.board[3][3] = WHITE;
        this.board[3][4] = BLACK;
        this.board[4][3] = BLACK;
        this.board[4][4] = WHITE;

        this.currentPlayer = BLACK; // è§„åˆ™å›ºå®š
        this.gameActive = true;
        this.moveHistoryString = ""; // ç”¨äºç®€æ˜“å¼€å±€åº“åŒ¹é…

        this.setupOverlayEl.classList.remove('show');
        this.updateGameState();
    }

    // --- æ ¸å¿ƒæ¸¸æˆé€»è¾‘ (ä¼˜åŒ–ç‰ˆï¼Œæ”¯æŒ AI åŸåœ°ä¿®æ”¹) ---

    // è·å–åˆæ³•èµ°æ³• (è¿”å›æ•°ç»„ï¼Œä¸ä¿®æ”¹æ£‹ç›˜)
    getValidMoves(player, board = this.board) {
        const moves = [];
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (board[r][c] !== EMPTY) continue;
                if (this.canFlip(r, c, player, board)) {
                    moves.push({ r, c });
                }
            }
        }
        return moves;
    }

    canFlip(r, c, player, board) {
        for (let i = 0; i < 8; i++) {
            const dr = DIRECTIONS[i][0];
            const dc = DIRECTIONS[i][1];
            let nr = r + dr;
            let nc = c + dc;
            let hasOpponent = false;

            while (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === -player) {
                nr += dr;
                nc += dc;
                hasOpponent = true;
            }

            if (hasOpponent && nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === player) {
                return true;
            }
        }
        return false;
    }

    // AI ä¸“ç”¨ï¼šæ‰§è¡Œè½å­å¹¶è¿”å›ç¿»è½¬çš„æ£‹å­åˆ—è¡¨ï¼ˆç”¨äºæ’¤é”€ï¼‰
    // è¿™æ˜¯ä¸€ä¸ªæåº¦ä¼˜åŒ–çš„åŸåœ°ä¿®æ”¹æ–¹æ³•
    makeMoveInPlace(board, r, c, player) {
        const flipped = [];
        board[r][c] = player;

        for (let i = 0; i < 8; i++) {
            const dr = DIRECTIONS[i][0];
            const dc = DIRECTIONS[i][1];
            let nr = r + dr;
            let nc = c + dc;
            let potentialFlip = [];

            while (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === -player) {
                potentialFlip.push({ r: nr, c: nc });
                nr += dr;
                nc += dc;
            }

            if (potentialFlip.length > 0 && nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === player) {
                for (let p of potentialFlip) {
                    board[p.r][p.c] = player;
                    flipped.push(p);
                }
            }
        }
        return flipped;
    }

    // AI ä¸“ç”¨ï¼šæ’¤é”€è½å­
    undoMoveInPlace(board, r, c, flipped, player) {
        board[r][c] = EMPTY;
        const opponent = -player;
        for (let p of flipped) {
            board[p.r][p.c] = opponent;
        }
    }

    // UI ä¸“ç”¨ï¼šæ‰§è¡Œè½å­ï¼ˆåˆ›å»ºæ–°çŠ¶æ€ï¼Œä¸ç”¨äºAIæœç´¢ï¼‰
    makeMoveUI(r, c, player) {
        this.makeMoveInPlace(this.board, r, c, player);
        this.moveHistoryString += `${r}${c}`;
    }

    // --- æ¸¸æˆæµç¨‹æ§åˆ¶ ---

    updateGameState() {
        this.renderBoard();
        this.updateScoreUI();

        const validMoves = this.getValidMoves(this.currentPlayer);
        
        if (validMoves.length === 0) {
            const opponentMoves = this.getValidMoves(-this.currentPlayer);
            if (opponentMoves.length === 0) {
                this.endGame();
                return;
            }
            // Pass
            const isHuman = this.currentPlayer === this.HUMAN_PLAYER;
            if (isHuman) {
                setTimeout(() => {
                    alert("ä½ æ— å¤„è½å­ï¼Œå›åˆè·³è¿‡ï¼");
                    this.changeTurn();
                }, 200);
            } else {
                setTimeout(() => {
                    console.log("AI Pass");
                    this.changeTurn();
                }, 500);
            }
        } else {
            if (this.currentPlayer === this.AI_PLAYER && this.gameActive) {
                // UI æ¸²æŸ“ç»™ä¸€ç‚¹å–˜æ¯æ—¶é—´ï¼Œç„¶å AI æ€è€ƒ
                setTimeout(() => this.aiMove(), 100); 
            }
        }
    }

    changeTurn() {
        this.currentPlayer = -this.currentPlayer;
        this.updateGameState();
    }

    handleCellClick(r, c) {
        if (!this.gameActive || this.currentPlayer !== this.HUMAN_PLAYER) return;
        // ç®€å•éªŒè¯åˆæ³•æ€§
        if (this.board[r][c] !== EMPTY) return;
        if (!this.canFlip(r, c, this.currentPlayer, this.board)) return;

        this.makeMoveUI(r, c, this.currentPlayer);
        this.changeTurn();
    }

    // --- é¡¶çº§ AI å¼•æ“å®ç° ---

    aiMove() {
        this.aiThinking = true;
        this.searchStartTime = Date.now();
        this.nodesSearched = 0;
        this.stopSearch = false;

        // 1. å¼€å±€ä¹¦æ£€æŸ¥
        const bookMove = this.checkOpeningBook();
        if (bookMove) {
            console.log("Opening Book Hit:", bookMove);
            this.makeMoveUI(bookMove.r, bookMove.c, this.AI_PLAYER);
            this.aiThinking = false;
            this.changeTurn();
            return;
        }

        // 2. åˆå§‹åŒ– AI å†…å­˜
        // ä¸¥æ ¼éµå¾ªè¦æ±‚ï¼šæ¯æ­¥æ€è€ƒå‰æ¸…ç©ºè¡¨
        this.tt.clear();
        this.historyTable = Array(2).fill(0).map(() => Array(ROWS).fill(0).map(() => Array(COLS).fill(0)));
        this.killerMoves = Array(64).fill(0).map(() => [null, null]);

        // 3. è®¡ç®—æ£‹ç›˜ç©ºä½æ•°ï¼Œå†³å®šç­–ç•¥
        const flatBoard = this.board.flat();
        const emptyCount = flatBoard.filter(c => c === EMPTY).length;
        
        // 4. è¿­ä»£åŠ æ·±æœç´¢ (Iterative Deepening)
        let bestMove = null;
        let bestScore = -Infinity;
        
        // æ·±åº¦è®¾å®š
        let maxDepth = 64; 
        if (emptyCount <= 16) maxDepth = emptyCount + 4; // æ®‹å±€å®Œç¾æœç´¢

        // åˆå§‹çª—å£
        let alpha = -Infinity;
        let beta = Infinity;

        // å¼€å§‹è¿­ä»£
        for (let depth = 1; depth <= maxDepth; depth++) {
            // Aspiration Windows ä¼˜åŒ–
            // åªæœ‰å½“æœ‰äº†åˆæ­¥ä¼°å€¼åæ‰ä½¿ç”¨çª—å£ä¼˜åŒ–
            let searchAlpha = alpha;
            let searchBeta = beta;
            if (depth > 2 && bestMove) {
                const window = 50;
                searchAlpha = bestScore - window;
                searchBeta = bestScore + window;
            } else {
                searchAlpha = -Infinity;
                searchBeta = Infinity;
            }

            try {
                // æ‰§è¡Œ PVS æœç´¢
                // è®¡ç®—å½“å‰ Zobrist Hash
                const hash = this.computeHash(this.board, this.currentPlayer);
                
                const score = this.pvs(this.board, depth, searchAlpha, searchBeta, this.currentPlayer, hash);
                
                // æ£€æŸ¥æ˜¯å¦è¶…æ—¶ä¸­æ­¢
                if (this.stopSearch) break;

                // çª—å£å¤–å¤±è´¥ (Fail Low/High)ï¼Œé‡æ–°å…¨çª—å£æœç´¢
                if (score <= searchAlpha || score >= searchBeta) {
                    // æ‰©å¤§çª—å£å†æœä¸€æ¬¡ (Panic search)
                    // console.log("Window fail, re-searching full window...");
                    const retryScore = this.pvs(this.board, depth, -Infinity, Infinity, this.currentPlayer, hash);
                    if (this.stopSearch) break;
                    bestScore = retryScore;
                } else {
                    bestScore = score;
                }
                
                // ä» TT ä¸­è·å–æœ€ä½³ç§»åŠ¨
                const entry = this.tt.get(hash);
                if (entry && entry.bestMove) {
                    bestMove = entry.bestMove;
                }

                // console.log(`Depth ${depth} done. Score: ${bestScore}. Move: ${bestMove?.r},${bestMove?.c}`);

                // æ®‹å±€å¦‚æœæœå®Œæ‰€æœ‰ç©ºä½ï¼Œç›´æ¥é€€å‡º
                if (emptyCount <= depth) break;

            } catch (e) {
                console.error(e);
                break;
            }
        }

        // 5. æ‰§è¡Œæœ€ä½³ç§»åŠ¨
        if (bestMove) {
            this.makeMoveUI(bestMove.r, bestMove.c, this.AI_PLAYER);
        } else {
            // æç½•è§æƒ…å†µï¼šæ— æ£‹å¯ä¸‹ï¼ˆåº”è¯¥è¢«å¤–å±‚é€»è¾‘æ‹¦æˆªï¼‰æˆ–æœç´¢å®Œå…¨è¢«å‰ªæ
            // éšæœºå…œåº•
            const moves = this.getValidMoves(this.AI_PLAYER);
            if (moves.length > 0) {
                const rnd = moves[Math.floor(Math.random() * moves.length)];
                this.makeMoveUI(rnd.r, rnd.c, this.AI_PLAYER);
            }
        }

        this.aiThinking = false;
        this.changeTurn();
    }

    // PVS (Principal Variation Search)
    pvs(board, depth, alpha, beta, color, hash) {
        // æ—¶é—´æ£€æŸ¥ (æ¯ 2048 èŠ‚ç‚¹æ£€æŸ¥ä¸€æ¬¡)
        if ((this.nodesSearched++ & 2047) === 0) {
            if (Date.now() - this.searchStartTime > this.timeLimit) {
                this.stopSearch = true;
            }
        }
        if (this.stopSearch) return 0;

        // 1. Transposition Table Lookup
        const ttEntry = this.tt.get(hash);
        if (ttEntry && ttEntry.depth >= depth) {
            if (ttEntry.flag === 0) return ttEntry.score; // Exact
            if (ttEntry.flag === 1 && ttEntry.score >= beta) return ttEntry.score; // Lower bound (Beta cut)
            if (ttEntry.flag === 2 && ttEntry.score <= alpha) return ttEntry.score; // Upper bound
        }

        // 2. Leaf Node or Game Over
        const moves = this.getValidMoves(color, board);
        if (depth === 0 || moves.length === 0) {
            if (moves.length === 0) {
                // å¦‚æœæˆ‘æ–¹æ— æ£‹å¯ä¸‹ï¼Œæ£€æŸ¥å¯¹æ–¹
                if (this.getValidMoves(-color, board).length === 0) {
                    // åŒæ–¹éƒ½æ— æ£‹å¯ä¸‹ï¼Œæ¸¸æˆç»“æŸï¼Œè¿”å›ç»å¯¹åˆ†å€¼
                    return this.evaluateFinal(board) * color; // ä¹˜ä»¥ color é€‚é… Minimax è§†è§’
                }
                // æˆ‘æ–¹æ— æ£‹ï¼Œpassï¼Œç»§ç»­æœ (ä¸å‡æ·±åº¦ï¼Œæˆ–å‡æ·±åº¦ä½†æ¢è¾¹)
                // è¿™é‡Œå¤„ç†ä¸ºï¼šæ·±åº¦-1ï¼Œæ¢è¾¹ï¼Œä¾ç„¶æ˜¯ PVS
                // éœ€è¦æ›´æ–° Hash æ¢æ‰‹
                const newHash = hash ^ ZobristBlackTurn; 
                return -this.pvs(board, depth - 1, -beta, -alpha, -color, newHash);
            }
            return this.evaluate(board, color);
        }

        // 3. Move Ordering
        this.orderMoves(moves, board, color, depth, ttEntry?.bestMove);

        // 4. PVS Loop
        let bestMove = null;
        let bestScore = -Infinity;
        let score;

        for (let i = 0; i < moves.length; i++) {
            const move = moves[i];
            
            // Do Move
            const flipped = this.makeMoveInPlace(board, move.r, move.c, color);
            // Update Hash (Incremental update complex, simplify to recompute for robustness in JS)
            // Or use simplified hash:
            // const nextHash = this.computeHash(board, -color); 
            // æ€§èƒ½ä¼˜åŒ–ï¼šé‡æ–°è®¡ç®— Hash è™½ç„¶æ…¢ï¼Œä½†æ¯” JS å®ç°å¤æ‚çš„å¢é‡ Hash æ›´ç¨³å¥
            const nextHash = this.computeHash(board, -color);

            if (i === 0) {
                // Principal Variation: Full window search
                score = -this.pvs(board, depth - 1, -beta, -alpha, -color, nextHash);
            } else {
                // Null Window Search (LMR can be added here)
                score = -this.pvs(board, depth - 1, -alpha - 1, -alpha, -color, nextHash);
                if (score > alpha && score < beta) {
                    // Fail High in null window, re-search full window
                    score = -this.pvs(board, depth - 1, -beta, -alpha, -color, nextHash);
                }
            }

            // Undo Move
            this.undoMoveInPlace(board, move.r, move.c, flipped, color);

            if (this.stopSearch) return 0;

            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }

            if (score > alpha) {
                alpha = score;
                if (alpha >= beta) {
                    // Beta Cutoff
                    this.updateHistory(move, depth, color);
                    this.updateKiller(move, depth);
                    break;
                }
            }
        }

        // 5. Store TT
        const flag = bestScore >= beta ? 1 : (bestScore > alpha ? 0 : 2); // 1: Lower, 0: Exact, 2: Upper
        // æ³¨æ„ï¼šè¿™é‡Œ alpha æ˜¯ä¼ å…¥çš„ alphaï¼Œè¿˜æ˜¯æ›´æ–°åçš„ï¼Ÿ PVS ä¸­é€šå¸¸æ¯”è¾ƒ original alpha
        // ç®€å•èµ·è§ï¼šScore >= Beta -> Lower Bound; Score <= AlphaOld -> Upper Bound; Else Exact
        
        if (!this.stopSearch) {
            this.tt.set(hash, {
                depth: depth,
                flag: flag,
                score: bestScore,
                bestMove: bestMove
            });
        }

        return bestScore;
    }

    // --- å¯å‘å¼ & è¯„ä¼° ---

    orderMoves(moves, board, color, depth, ttMove) {
        moves.forEach(move => {
            let score = 0;
            // 1. TT Move (Hash Move)
            if (ttMove && move.r === ttMove.r && move.c === ttMove.c) {
                score = 1000000;
            } else {
                // 2. MVV-LVA (Simplified: count flipped)
                // æ¨¡æ‹Ÿç¿»è½¬æ•°é‡ (å¼€é”€æœ‰ç‚¹å¤§ï¼Œè¿™é‡Œç”¨ç®€åŒ–çš„é™æ€ä½ç½®åˆ†ä»£æ›¿ï¼Œæˆ–å¿«é€Ÿä¼°ç®—)
                score += STATIC_WEIGHTS[move.r][move.c];

                // 3. Killer Moves
                if (this.isKiller(move, depth)) score += 90000;

                // 4. History Heuristic
                const hScore = this.historyTable[color === BLACK ? 0 : 1][move.r][move.c];
                score += hScore;
            }
            move.sortScore = score;
        });
        moves.sort((a, b) => b.sortScore - a.sortScore);
    }

    updateHistory(move, depth, color) {
        const pIdx = color === BLACK ? 0 : 1;
        this.historyTable[pIdx][move.r][move.c] += depth * depth;
    }

    updateKiller(move, depth) {
        if (this.killerMoves[depth][0] && 
            this.killerMoves[depth][0].r === move.r && 
            this.killerMoves[depth][0].c === move.c) return;
        
        this.killerMoves[depth][1] = this.killerMoves[depth][0];
        this.killerMoves[depth][0] = move;
    }

    isKiller(move, depth) {
        return (this.killerMoves[depth][0] && this.killerMoves[depth][0].r === move.r && this.killerMoves[depth][0].c === move.c) ||
               (this.killerMoves[depth][1] && this.killerMoves[depth][1].r === move.r && this.killerMoves[depth][1].c === move.c);
    }

    // èŒä¸šçº§è¯„ä¼°å‡½æ•°
    evaluate(board, color) {
        let myScore = 0;
        let opScore = 0;
        const opColor = -color;

        // 1. é™æ€ä½ç½®åˆ† + ç¨³å®šå­åˆ¤å®š (Corner Stability)
        // 2. è¡ŒåŠ¨åŠ› (Mobility)
        // 3. æ½œåœ¨è¡ŒåŠ¨åŠ› (Frontier)
        
        // å¿«é€Ÿæ‰«æ
        let myMobility = 0;
        let opMobility = 0;
        let myFrontier = 0;
        let opFrontier = 0;

        // è¡ŒåŠ¨åŠ›è®¡ç®—ï¼ˆè¾ƒæ˜‚è´µï¼Œä½†å¿…é¡»ç®—ï¼‰
        // ä¸ºäº†æ€§èƒ½ï¼Œè¿™é‡Œæˆ‘ä»¬æ‰‹åŠ¨è®¡ç®— valid moves çš„æ•°é‡è€Œä¸æ˜¯è°ƒç”¨ getValidMoves
        // ä½† JS ä¸­ getValidMoves ä¼˜åŒ–è¿‡ï¼Œç›´æ¥è°ƒç”¨ä¹Ÿè¡Œ
        const myMoves = this.getValidMoves(color, board);
        const opMoves = this.getValidMoves(opColor, board);
        myMobility = myMoves.length;
        opMobility = opMoves.length;

        // è§’è½ä¸ç¨³å®šæ€§æ‰«æ
        const corners = [[0,0], [0,7], [7,0], [7,7]];
        corners.forEach(([r, c]) => {
            if (board[r][c] === color) {
                myScore += 800; // å·²å è§’
                // TODO: æ‰©æ•£è®¡ç®—ç¨³å®šå­ (ç®€åŒ–ï¼šè§’åŠé‚»è¾¹)
                myScore += 30 * this.countStableEdge(board, r, c, color);
            } else if (board[r][c] === opColor) {
                opScore += 800;
                opScore += 30 * this.countStableEdge(board, r, c, opColor);
            } else {
                // è§’è½ä¸ºç©ºï¼Œæ£€æŸ¥ Xä½ Cä½ æƒ©ç½š
                this.evaluateXCSquares(board, r, c, color, (val) => myScore += val);
                this.evaluateXCSquares(board, r, c, opColor, (val) => opScore += val);
            }
        });

        // åŸºç¡€ä½ç½®åˆ†ç´¯åŠ 
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<COLS; c++){
                if(board[r][c] === color) {
                    myScore += STATIC_WEIGHTS[r][c];
                    // Frontier ç®€åŒ–è®¡ç®—ï¼šå¦‚æœå‘¨å›´æœ‰ç©ºä½ï¼Œå°±æ˜¯æ½œåœ¨è¡ŒåŠ¨åŠ›ç»™äºˆå¯¹æ–¹
                    if(this.isFrontier(board, r, c)) opFrontier++;
                } else if(board[r][c] === opColor) {
                    opScore += STATIC_WEIGHTS[r][c];
                    if(this.isFrontier(board, r, c)) myFrontier++;
                }
            }
        }

        // ç»¼åˆåŠ æƒ
        let score = (myScore - opScore);
        score += (myMobility - opMobility) * 20;
        score += (myFrontier - opFrontier) * 12; // æ½œåœ¨è¡ŒåŠ¨åŠ›è¶Šé«˜è¶Šå¥½
        
        return score;
    }

    evaluateXCSquares(board, cornerR, cornerC, color, addScore) {
        // å®šä¹‰ç›¸å¯¹äºè§’çš„ X, C ä½ç½®
        // è¿™é‡Œéœ€è¦ç²¾ç»†é€»è¾‘ï¼Œç®€åŒ–å¤„ç†ï¼šå¦‚æœè§’æ˜¯ç©ºï¼Œä¸”è‡ªå·±ä¸‹äº†æ˜Ÿä½(X)ï¼Œé‡ç½š
        // 0,0 çš„ Xæ˜¯ 1,1; Cæ˜¯ 0,1 å’Œ 1,0
        let xr, xc, c1r, c1c, c2r, c2c;
        if (cornerR===0 && cornerC===0) { xr=1; xc=1; c1r=0; c1c=1; c2r=1; c2c=0; }
        else if (cornerR===0 && cornerC===7) { xr=1; xc=6; c1r=0; c1c=6; c2r=1; c2c=7; }
        else if (cornerR===7 && cornerC===0) { xr=6; xc=1; c1r=7; c1c=1; c2r=6; c2c=0; }
        else { xr=6; xc=6; c1r=7; c1c=6; c2r=6; c2c=7; }

        if (board[xr][xc] === color) addScore(-400); // å±é™©çš„æ˜Ÿä½
        if (board[c1r][c1c] === color) addScore(-200);
        if (board[c2r][c2c] === color) addScore(-200);
    }

    countStableEdge(board, r, c, color) {
        // ç®€æ˜“ç¨³å®šå­ï¼šå¦‚æœå äº†è§’ï¼Œå¾€ä¸¤è¾¹å»¶ä¼¸çš„åŒè‰²å­è§†ä¸ºç¨³å®š
        let stable = 0;
        // ç•¥å¾®ç®€åŒ–ï¼Œåªç®—ç´§é‚»çš„
        return stable; 
    }

    isFrontier(board, r, c) {
        for(let d of DIRECTIONS) {
            let nr = r + d[0], nc = c + d[1];
            if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && board[nr][nc] === EMPTY) return true;
        }
        return false;
    }

    evaluateFinal(board) {
        // ç»ˆå±€ç»å¯¹åˆ†å·®
        let diff = 0;
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<COLS; c++){
                if(board[r][c] === this.AI_PLAYER) diff++;
                else if(board[r][c] === this.HUMAN_PLAYER) diff--;
            }
        }
        return diff * 10000;
    }

    // è®¡ç®— BigInt Zobrist Hash
    computeHash(board, turn) {
        let h = 0n;
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (board[r][c] !== EMPTY) {
                    h ^= ZobristTable[r * 8 + c][board[r][c]];
                }
            }
        }
        if (turn === BLACK) h ^= ZobristBlackTurn;
        return h;
    }

    checkOpeningBook() {
        // ç®€å•åŒ¹é…
        // è¿™é‡Œåªæ˜¯ç¤ºæ„ï¼Œå®é™…å¯ä»¥ä½¿ç”¨ moveHistoryString åŒ¹é… OPENING_RESPONSES çš„ key
        // å‡è®¾ OPENING_RESPONSES key æ˜¯ "23" ä»£è¡¨ç¬¬ä¸€æ­¥ä¸‹äº† (2,3)
        // å®é™…é¡¹ç›®éœ€æ„å»ºå®Œæ•´å‰ç¼€æ ‘
        if (OPENING_RESPONSES[this.moveHistoryString]) {
            const [r, c] = OPENING_RESPONSES[this.moveHistoryString];
            return {r, c};
        }
        return null;
    }

    // --- UI æ›´æ–°ç›¸å…³ ---
    renderBoard() {
        this.boardEl.innerHTML = '';
        const validMoves = this.gameActive ? this.getValidMoves(this.currentPlayer) : [];
        const isHumanTurn = this.currentPlayer === this.HUMAN_PLAYER;

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                
                if (this.gameActive && isHumanTurn && validMoves.some(m => m.r === r && m.c === c)) {
                    cell.classList.add('valid');
                    cell.onclick = () => this.handleCellClick(r, c);
                }

                const val = this.board[r][c];
                if (val !== EMPTY) {
                    const piece = document.createElement('div');
                    piece.className = `piece ${val === BLACK ? 'black' : 'white'}`;
                    cell.appendChild(piece);
                }
                this.boardEl.appendChild(cell);
            }
        }

        // æ›´æ–°çŠ¶æ€æ–‡å­—
        const isBlack = this.currentPlayer === BLACK;
        let turnText = isHumanTurn ? (isBlack ? "é»‘æ£‹ (ä½ )" : "ç™½æ£‹ (ä½ )") : (isBlack ? "é»‘æ£‹ (AI)" : "ç™½æ£‹ (AI)");
        if (this.aiThinking) turnText += " æ€è€ƒä¸­...";
        
        this.turnDisplayEl.textContent = turnText + " çš„å›åˆ";
        this.turnDisplayEl.style.backgroundColor = isHumanTurn ? "#e3f2fd" : "#ffebee";
        this.turnDisplayEl.style.color = isHumanTurn ? "#1565c0" : "#c62828";

        // æ›´æ–°æ ‡ç­¾
        const blackLabel = document.querySelector('.score-box:first-child .score-label');
        const whiteLabel = document.querySelector('.score-box:last-child .score-label');
        blackLabel.textContent = this.HUMAN_PLAYER === BLACK ? "é»‘æ£‹ (ä½ )" : "é»‘æ£‹ (AI)";
        whiteLabel.textContent = this.HUMAN_PLAYER === WHITE ? "ç™½æ£‹ (ä½ )" : "ç™½æ£‹ (AI)";
    }

    updateScoreUI() {
        let b = 0, w = 0;
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
            if(this.board[r][c]===BLACK) b++;
            else if(this.board[r][c]===WHITE) w++;
        }
        this.scoreBlackEl.innerText = b;
        this.scoreWhiteEl.innerText = w;
    }

    endGame() {
        this.gameActive = false;
        const b = parseInt(this.scoreBlackEl.innerText);
        const w = parseInt(this.scoreWhiteEl.innerText);
        let humanScore = this.HUMAN_PLAYER === BLACK ? b : w;
        let aiScore = this.HUMAN_PLAYER === BLACK ? w : b;
        
        let title = humanScore > aiScore ? "æ­å–œï¼ä½ èµ¢äº†ï¼ğŸ‰" : (aiScore > humanScore ? "AI è·èƒœï¼ğŸ¤–" : "å¹³å±€ï¼ğŸ¤");
        this.msgTitleEl.innerText = title;
        this.msgContentEl.innerText = `é»‘æ£‹: ${b} | ç™½æ£‹: ${w}`;
        this.endOverlayEl.classList.add('show');
    }
}

const game = new OthelloGame();

</script>
</body>
</html>
