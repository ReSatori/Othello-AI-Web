<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»‘ç™½æ£‹ (Othello) - äººæœºå¯¹æˆ˜</title>
    <style>
        :root {
            --board-bg: #2e7d32; /* ç»å…¸çš„æ£‹ç›˜ç»¿ */
            --board-border: #1b5e20;
            --cell-border: rgba(0, 0, 0, 0.2);
            --black-piece: #1a1a1a;
            --white-piece: #f0f0f0;
            --hint-color: rgba(0, 0, 0, 0.2);
            --hint-hover: rgba(0, 0, 0, 0.4);
            --primary-btn: #1976d2;
            --primary-btn-hover: #1565c0;
            --text-color: #333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #eef2f3;
            color: var(--text-color);
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        /* --- ä¿¡æ¯é¢æ¿ --- */
        .info-panel {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: white;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 500px;
            justify-content: space-around;
            align-items: center;
        }

        .score-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .score-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-indicator.black { background-color: var(--black-piece); }
        .score-indicator.white { background-color: var(--white-piece); border: 1px solid #ccc; }

        .turn-display {
            font-weight: bold;
            color: #d32f2f; /* é†’ç›®çš„é¢œè‰²æ˜¾ç¤ºå½“å‰å›åˆ */
            padding: 5px 15px;
            background: #ffebee;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        /* --- æ£‹ç›˜ --- */
        .board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            background-color: var(--board-border);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            background-color: var(--board-border); /* ä¿®æ”¹è¿™é‡Œï¼šä½¿ç”¨æ·±è‰²èƒŒæ™¯ï¼Œè®© gap æ˜¾ç¤ºä¸ºçº¿æ¡ */
            gap: 2px; /* å¢åŠ ä¸€ç‚¹é—´éš™å®½åº¦ï¼Œè®©çº¿æ¡æ›´æ¸…æ™° */
            border: 4px solid var(--board-border); /* åŠ ç²—å¤–è¾¹æ¡† */
        }

        .cell {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: var(--board-bg);
            cursor: default;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* åªæœ‰åˆæ³•çš„æ ¼å­æ‰æœ‰é¼ æ ‡æ‰‹åŠ¿ */
        .cell.valid {
            cursor: pointer;
        }

        /* æç¤ºç‚¹ (Legal Move Hint) */
        .cell.valid::after {
            content: '';
            width: 30%;
            height: 30%;
            background-color: var(--hint-color);
            border-radius: 50%;
            transition: transform 0.2s, background-color 0.2s;
        }

        .cell.valid:hover::after {
            background-color: var(--hint-hover);
            transform: scale(1.2);
        }

        /* --- æ£‹å­ --- */
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5), inset -2px -2px 5px rgba(0,0,0,0.2);
            position: absolute;
            transition: transform 0.4s ease-in-out, background-color 0.4s;
            backface-visibility: hidden;
        }

        .piece.black {
            background-color: var(--black-piece);
            background: radial-gradient(circle at 30% 30%, #444, var(--black-piece));
        }

        .piece.white {
            background-color: var(--white-piece);
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
        }

        /* ç¿»è½¬åŠ¨ç”»çš„è¾…åŠ©ç±» */
        .piece.flipping {
            transform: scale(0);
        }

        /* --- æ§åˆ¶åŒº --- */
        .controls {
            margin-top: 25px;
        }

        .btn {
            background-color: var(--primary-btn);
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background-color: var(--primary-btn-hover);
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* --- æ¶ˆæ¯å¼¹çª— --- */
        .message-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .message-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .message-box {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            max-width: 90%;
        }

        .message-box h2 {
            margin-bottom: 10px;
            color: #333;
        }

        .message-box p {
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 600px) {
            .board-container {
                max-width: 90vw;
            }
            .info-panel {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>

    <h1>é»‘ç™½æ£‹ (Reversi)</h1>

    <div class="info-panel">
        <div class="score-box">
            <span class="score-label">é»‘æ£‹ (ç©å®¶)</span>
            <span class="score-value">
                <span class="score-indicator black"></span>
                <span id="score-black">2</span>
            </span>
        </div>
        
        <div class="turn-display" id="turn-display">é»‘æ£‹çš„å›åˆ</div>

        <div class="score-box">
            <span class="score-label">ç™½æ£‹ (AI)</span>
            <span class="score-value">
                <span class="score-indicator white"></span>
                <span id="score-white">2</span>
            </span>
        </div>
    </div>

    <div class="board-container">
        <div class="board" id="board">
            <!-- ç½‘æ ¼ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="game.initGame()">é‡æ–°å¼€å§‹ (New Game)</button>
    </div>

    <!-- æ¸¸æˆç»“æŸ/æ¶ˆæ¯å¼¹çª— -->
    <div class="message-overlay" id="message-overlay">
        <div class="message-box">
            <h2 id="msg-title">æ¸¸æˆç»“æŸ</h2>
            <p id="msg-content">é»‘æ£‹èƒœï¼</p>
            <button class="btn" onclick="game.closeOverlay()">ç¡®å®š</button>
        </div>
    </div>

<script>
/**
 * é»‘ç™½æ£‹ (Othello) æ¸¸æˆé€»è¾‘ä¸AI
 * * çº¦å®š:
 * Board: 8x8 äºŒç»´æ•°ç»„
 * 1 = é»‘æ£‹ (ç©å®¶)
 * -1 = ç™½æ£‹ (AI)
 * 0 = ç©º
 */

class OthelloGame {
    constructor() {
        this.ROWS = 8;
        this.COLS = 8;
        this.board = [];
        this.currentPlayer = 1; // 1: Black, -1: White
        this.gameActive = false;
        this.validMoves = [];
        
        // AI é…ç½®
        this.AI_PLAYER = -1;
        this.HUMAN_PLAYER = 1;
        this.AI_DEPTH = 6; // åŸºç¡€æ·±åº¦æå‡åˆ° 6

        // ä½ç½®æƒé‡çŸ©é˜µ (ä¼˜åŒ–ç‰ˆ - æ›´åŠ å¼ºè°ƒè§’è½å’ŒåŒºåŸŸæ§åˆ¶)
        this.WEIGHTS = [
            [500, -80, 10,  5,  5, 10, -80, 500],
            [-80, -100, -5, -5, -5, -5, -100, -80],
            [ 10,  -5,  2,  1,  1,  2,  -5,  10],
            [  5,  -5,  1,  5,  5,  1,  -5,   5],
            [  5,  -5,  1,  5,  5,  1,  -5,   5],
            [ 10,  -5,  2,  1,  1,  2,  -5,  10],
            [-80, -100, -5, -5, -5, -5, -100, -80],
            [500, -80, 10,  5,  5, 10, -80, 500]
        ];

        // ç»‘å®šUIå…ƒç´ 
        this.boardEl = document.getElementById('board');
        this.scoreBlackEl = document.getElementById('score-black');
        this.scoreWhiteEl = document.getElementById('score-white');
        this.turnDisplayEl = document.getElementById('turn-display');
        this.overlayEl = document.getElementById('message-overlay');
        this.msgTitleEl = document.getElementById('msg-title');
        this.msgContentEl = document.getElementById('msg-content');

        this.initGame();
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    initGame() {
        // åˆ›å»ºç©ºæ£‹ç›˜
        this.board = Array(this.ROWS).fill().map(() => Array(this.COLS).fill(0));
        
        // æ”¾ç½®åˆå§‹4é¢—æ£‹å­
        this.board[3][3] = -1;
        this.board[3][4] = 1;
        this.board[4][3] = 1;
        this.board[4][4] = -1;

        this.currentPlayer = 1; // é»‘æ£‹å…ˆæ‰‹
        this.gameActive = true;
        this.closeOverlay();
        
        this.updateGameState();
    }

    // è®¡ç®—å½“å‰ç©å®¶çš„æ‰€æœ‰åˆæ³•è½å­ç‚¹
    getValidMoves(player, boardState = this.board) {
        let moves = [];
        for (let r = 0; r < this.ROWS; r++) {
            for (let c = 0; c < this.COLS; c++) {
                if (boardState[r][c] !== 0) continue; // å¿…é¡»æ˜¯ç©ºä½
                if (this.canFlip(r, c, player, boardState)) {
                    moves.push({ r, c });
                }
            }
        }
        return moves;
    }

    // æ£€æŸ¥åœ¨(r, c)è½å­æ˜¯å¦åˆæ³•ï¼ˆæ˜¯å¦èƒ½ç¿»è½¬å¯¹æ–¹æ£‹å­ï¼‰
    canFlip(r, c, player, boardState) {
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        for (let [dr, dc] of directions) {
            let nr = r + dr;
            let nc = c + dc;
            let hasOpponent = false;

            // æ²¿ç€æ–¹å‘å‰è¿›ï¼Œå…ˆè¦é‡åˆ°å¯¹æ–¹æ£‹å­
            while (this.isOnBoard(nr, nc) && boardState[nr][nc] === -player) {
                nr += dr;
                nc += dc;
                hasOpponent = true;
            }

            // æœ€åå¿…é¡»é‡åˆ°è‡ªå·±çš„æ£‹å­
            if (hasOpponent && this.isOnBoard(nr, nc) && boardState[nr][nc] === player) {
                return true;
            }
        }
        return false;
    }

    isOnBoard(r, c) {
        return r >= 0 && r < this.ROWS && c >= 0 && c < this.COLS;
    }

    // æ‰§è¡Œè½å­å¹¶ç¿»è½¬æ£‹å­
    makeMove(r, c, player, isRealMove = true) {
        if (!isRealMove) {
            // å¦‚æœæ˜¯AIæ¨¡æ‹Ÿï¼Œæˆ‘ä»¬éœ€è¦å…‹éš†ä¸€ä¸ªæ£‹ç›˜
            let newBoard = this.board.map(row => [...row]);
            this.executeFlip(r, c, player, newBoard);
            return newBoard;
        } else {
            // çœŸå®è½å­
            this.executeFlip(r, c, player, this.board);
            return this.board;
        }
    }

    // å…·ä½“çš„ç¿»è½¬é€»è¾‘
    executeFlip(r, c, player, boardState) {
        boardState[r][c] = player;
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        for (let [dr, dc] of directions) {
            let nr = r + dr;
            let nc = c + dc;
            let piecesToFlip = [];

            while (this.isOnBoard(nr, nc) && boardState[nr][nc] === -player) {
                piecesToFlip.push({ r: nr, c: nc });
                nr += dr;
                nc += dc;
            }

            if (piecesToFlip.length > 0 && this.isOnBoard(nr, nc) && boardState[nr][nc] === player) {
                for (let p of piecesToFlip) {
                    boardState[p.r][p.c] = player;
                }
            }
        }
    }

    // æ›´æ–°æ¸¸æˆçŠ¶æ€ï¼ˆæ¸²æŸ“ã€è®¡ç®—åˆ†æ•°ã€åˆ¤æ–­èƒœè´Ÿã€åˆ‡æ¢å›åˆï¼‰
    updateGameState() {
        this.validMoves = this.getValidMoves(this.currentPlayer);
        this.renderBoard();
        this.updateScoreUI();

        // æ£€æŸ¥å½“å‰ç©å®¶æ˜¯å¦æœ‰æ£‹å¯ä¸‹
        if (this.validMoves.length === 0) {
            // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰æ£‹å¯ä¸‹
            const opponentMoves = this.getValidMoves(-this.currentPlayer);
            if (opponentMoves.length === 0) {
                this.endGame();
            } else {
                // å½“å‰ç©å®¶æ— æ³•è½å­ï¼Œè·³è¿‡å›åˆ
                const playerName = this.currentPlayer === 1 ? "é»‘æ£‹ (ä½ )" : "ç™½æ£‹ (AI)";
                // å¦‚æœæ˜¯äººç±»è¢«è·³è¿‡ï¼Œç»™ä¸ªæç¤º
                if (this.currentPlayer === this.HUMAN_PLAYER) {
                    alert(`${playerName} æ— å¤„è½å­ï¼Œè·³è¿‡å›åˆï¼`);
                }
                this.changeTurn();
            }
        } else {
            // å¦‚æœæ˜¯AIçš„å›åˆï¼Œè§¦å‘AIæ€è€ƒ
            if (this.currentPlayer === this.AI_PLAYER && this.gameActive) {
                // ç¨å¾®ç»™ç‚¹å»¶è¿Ÿï¼Œè®©UIæ¸²æŸ“å®Œæˆ
                setTimeout(() => this.aiMove(), 100); 
            }
        }
    }

    changeTurn() {
        this.currentPlayer = -this.currentPlayer;
        this.updateGameState();
    }

    handleCellClick(r, c) {
        // åªæœ‰æ¸¸æˆè¿›è¡Œä¸­ã€è½®åˆ°äººç±»ã€ä¸”æ˜¯åˆæ³•ä½ç½®æ—¶æ‰å“åº”
        if (!this.gameActive || this.currentPlayer !== this.HUMAN_PLAYER) return;

        // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦åœ¨åˆæ³•åˆ—è¡¨ä¸­
        const isValid = this.validMoves.some(m => m.r === r && m.c === c);
        if (isValid) {
            this.makeMove(r, c, this.currentPlayer);
            this.changeTurn();
        }
    }

    // --- AI é€»è¾‘ (Minimax + Alpha-Beta Pruning) ---

    aiMove() {
        if (!this.gameActive) return;

        // åŠ¨æ€è°ƒæ•´æ·±åº¦ç­–ç•¥
        const flatBoard = this.board.flat();
        const emptyCells = flatBoard.filter(c => c === 0).length;
        
        let searchDepth = this.AI_DEPTH;

        // ç»ˆå±€æ¨¡å¼ï¼šå½“ç©ºä½å¾ˆå°‘æ—¶ï¼Œç©·ä¸¾æœç´¢ï¼ˆç®—å‡ºå¿…èƒœæ­¥ï¼‰
        if (emptyCells <= 12) {
            searchDepth = 12; 
        } else if (emptyCells <= 16) {
            searchDepth = 8;
        }

        // å¤åˆ¶å½“å‰æ£‹ç›˜çŠ¶æ€è¿›è¡Œè®¡ç®—
        const boardCopy = this.board.map(row => [...row]);
        const bestMove = this.minimax(boardCopy, searchDepth, -Infinity, Infinity, true);

        if (bestMove && bestMove.move) {
            this.makeMove(bestMove.move.r, bestMove.move.c, this.AI_PLAYER);
            this.changeTurn();
        } else {
            this.changeTurn();
        }
    }

    /**
     * Minimax é€’å½’å‡½æ•°
     */
    minimax(nodeBoard, depth, alpha, beta, maximizingPlayer) {
        const player = maximizingPlayer ? this.AI_PLAYER : this.HUMAN_PLAYER;
        let validMoves = this.getValidMoves(player, nodeBoard);

        // ç»ˆæ­¢æ¡ä»¶ï¼šè¾¾åˆ°æ·±åº¦ æˆ– æ¸¸æˆç»“æŸï¼ˆæ— è·¯å¯èµ°ï¼‰
        // å¦‚æœåŒæ–¹éƒ½æ²¡æ£‹èµ°äº†ï¼Œä¹Ÿç®—ç»“æŸ
        if (depth === 0 || (validMoves.length === 0 && this.getValidMoves(-player, nodeBoard).length === 0)) {
            return { score: this.evaluateBoard(nodeBoard) };
        }

        // å¦‚æœä¸€æ–¹æ— è·¯å¯èµ°ä½†æ¸¸æˆæœªç»“æŸï¼Œè¿™å±‚ä¾ç„¶è¦å¤„ç†ï¼ˆç›¸å½“äºPassï¼Œä¸å‡æ·±åº¦æˆ–å‡æ·±åº¦ç”±ç­–ç•¥å®šï¼Œè¿™é‡Œç®€å•å¤„ç†ç»§ç»­æœï¼‰
        if (validMoves.length === 0) {
            return this.minimax(nodeBoard, depth - 1, alpha, beta, !maximizingPlayer);
        }

        // --- å¯å‘å¼ä¼˜åŒ–ï¼šMove Ordering ---
        // ä¼˜å…ˆæœç´¢â€œæƒé‡é«˜â€çš„ä½ç½®ï¼ˆå¦‚è§’è½ï¼‰ï¼Œè¿™æ ·èƒ½æ›´å¿«è§¦å‘å‰ªæ
        validMoves.sort((a, b) => {
            return this.WEIGHTS[b.r][b.c] - this.WEIGHTS[a.r][a.c];
        });

        if (maximizingPlayer) {
            let maxEval = -Infinity;
            let bestMove = null;

            for (let move of validMoves) {
                const newBoard = nodeBoard.map(row => [...row]);
                this.executeFlip(move.r, move.c, this.AI_PLAYER, newBoard);

                const evalResult = this.minimax(newBoard, depth - 1, alpha, beta, false);
                
                if (evalResult.score > maxEval) {
                    maxEval = evalResult.score;
                    bestMove = move;
                }
                alpha = Math.max(alpha, evalResult.score);
                if (beta <= alpha) break; // Beta å‰ªæ
            }
            return { score: maxEval, move: bestMove };

        } else {
            let minEval = Infinity;
            let bestMove = null;

            for (let move of validMoves) {
                const newBoard = nodeBoard.map(row => [...row]);
                this.executeFlip(move.r, move.c, this.HUMAN_PLAYER, newBoard);

                const evalResult = this.minimax(newBoard, depth - 1, alpha, beta, true);

                if (evalResult.score < minEval) {
                    minEval = evalResult.score;
                    bestMove = move;
                }
                beta = Math.min(beta, evalResult.score);
                if (beta <= alpha) break; // Alpha å‰ªæ
            }
            return { score: minEval, move: bestMove };
        }
    }

    // è¯„ä¼°å‡½æ•°ï¼šå†³å®šå±€åŠ¿å¥½åçš„æ ¸å¿ƒ
    evaluateBoard(boardState) {
        let blackScore = 0;
        let whiteScore = 0;
        
        const flatBoard = boardState.flat();
        const emptyCount = flatBoard.filter(c => c === 0).length;

        // --- é˜¶æ®µ 1: ç»ˆå±€åˆ¤æ–­ ---
        // å¦‚æœæ¸¸æˆç»“æŸï¼ˆæˆ–éå¸¸æ¥è¿‘ç»“æŸï¼‰ï¼Œåªçœ‹æ£‹å­æ•°é‡ï¼Œè°å¤šè°èµ¢
        if (emptyCount === 0) {
            const blackCount = flatBoard.filter(c => c === this.HUMAN_PLAYER).length;
            const whiteCount = flatBoard.filter(c => c === this.AI_PLAYER).length;
            return (whiteCount - blackCount) * 10000; // æ”¾å¤§åˆ†å€¼ï¼Œç¡®ä¿AIä¼˜å…ˆé€‰æ‹©å¿…èƒœè·¯å¾„
        }

        // --- é˜¶æ®µ 2: è¿‡ç¨‹è¯„ä¼° ---
        
        // A. ä½ç½®æƒé‡åˆ† (Position Strategy)
        for (let r = 0; r < this.ROWS; r++) {
            for (let c = 0; c < this.COLS; c++) {
                const val = boardState[r][c];
                if (val === this.AI_PLAYER) whiteScore += this.WEIGHTS[r][c]; 
                else if (val === this.HUMAN_PLAYER) blackScore += this.WEIGHTS[r][c];
            }
        }

        // B. è¡ŒåŠ¨åŠ› (Mobility Strategy)
        // è®¡ç®—åŒæ–¹æœ‰å¤šå°‘ç§åˆæ³•èµ°æ³•ã€‚èµ°æ³•è¶Šå¤šï¼Œé€šå¸¸æ„å‘³ç€è¶Šä¸»åŠ¨ï¼Œè¶Šä¸å®¹æ˜“è¢«å¯¹æ–¹é€¼å…¥æ­»è§’ã€‚
        const blackMovesCount = this.getValidMoves(this.HUMAN_PLAYER, boardState).length;
        const whiteMovesCount = this.getValidMoves(this.AI_PLAYER, boardState).length;
        
        // è¡ŒåŠ¨åŠ›åœ¨å¼€å±€å’Œä¸­å±€éå¸¸é‡è¦
        const mobilityWeight = 15; 
        whiteScore += whiteMovesCount * mobilityWeight;
        blackScore += blackMovesCount * mobilityWeight;

        // è¿”å›åˆ†å·® (AI - Human)
        return whiteScore - blackScore;
    }

    // --- UI æ¸²æŸ“ç›¸å…³ ---

    renderBoard() {
        this.boardEl.innerHTML = '';
        
        for (let r = 0; r < this.ROWS; r++) {
            for (let c = 0; c < this.COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯åˆæ³•ä½ç½®ï¼ˆä»…é’ˆå¯¹äººç±»ç©å®¶æ˜¾ç¤ºæç¤ºï¼‰
                if (this.currentPlayer === this.HUMAN_PLAYER && 
                    this.validMoves.some(m => m.r === r && m.c === c)) {
                    cell.classList.add('valid');
                    cell.onclick = () => this.handleCellClick(r, c);
                }

                // æ¸²æŸ“æ£‹å­
                const cellValue = this.board[r][c];
                if (cellValue !== 0) {
                    const piece = document.createElement('div');
                    piece.className = `piece ${cellValue === 1 ? 'black' : 'white'}`;
                    cell.appendChild(piece);
                }

                this.boardEl.appendChild(cell);
            }
        }
        
        // æ›´æ–°å›åˆæ–‡å­—
        const isBlack = this.currentPlayer === 1;
        this.turnDisplayEl.textContent = isBlack ? "é»‘æ£‹çš„å›åˆ (ä½ )" : "ç™½æ£‹çš„å›åˆ (AIè®¡ç®—ä¸­...)";
        this.turnDisplayEl.style.backgroundColor = isBlack ? "#e0e0e0" : "#ffebee";
        this.turnDisplayEl.style.color = isBlack ? "#000" : "#d32f2f";
    }

    updateScoreUI() {
        let black = 0, white = 0;
        for (let r = 0; r < this.ROWS; r++) {
            for (let c = 0; c < this.COLS; c++) {
                if (this.board[r][c] === 1) black++;
                else if (this.board[r][c] === -1) white++;
            }
        }
        this.scoreBlackEl.innerText = black;
        this.scoreWhiteEl.innerText = white;
    }

    endGame() {
        this.gameActive = false;
        const black = parseInt(this.scoreBlackEl.innerText);
        const white = parseInt(this.scoreWhiteEl.innerText);
        
        let title = "";
        let content = `é»‘æ£‹: ${black} | ç™½æ£‹: ${white}`;

        if (black > white) {
            title = "æ­å–œï¼ä½ èµ¢äº†ï¼ğŸ‰";
        } else if (white > black) {
            title = "é—æ†¾ï¼ŒAI è·èƒœï¼ğŸ¤–";
        } else {
            title = "å¹³å±€ï¼ğŸ¤";
        }

        this.showOverlay(title, content);
    }

    showOverlay(title, content) {
        this.msgTitleEl.innerText = title;
        this.msgContentEl.innerText = content;
        this.overlayEl.classList.add('show');
    }

    closeOverlay() {
        this.overlayEl.classList.remove('show');
    }
}

// å¯åŠ¨æ¸¸æˆ
const game = new OthelloGame();

</script>
</body>
</html>
